{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red193\green101\blue28;\red64\green11\blue217;\red180\green36\blue25;
\red47\green180\blue29;\red200\green20\blue201;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 package\cf0  main\
\
\cf3  \cf0 \
\cf2 import\cf0  (\
        \cf4 "bytes"\cf0 \
        \cf4 "encoding/json"\cf0 \
        \cf4 "fmt"\cf0 \
        \cf4 "strconv"\cf0 \
\
        \cf4 "github.com/hyperledger/fabric/core/chaincode/shim"\cf0 \
        sc \cf4 "github.com/hyperledger/fabric/protos/peer"\cf0 \
)\
\
\
\cf3 // AML based chaincode, made for the transferring between to peers\
// OBS: query the ID first before starting balance.\
//locking is final and irreversible\
 \cf0 \
\cf2 type\cf0  AML \cf2 struct\cf0  \{\
\}\
\
\cf3 // Define the AML structure, with 9 properties. Every person has a unique ID\
//\cf0 \
\cf2 type\cf0  Transfer \cf2 struct\cf0  \{\
        ObjectType   \cf5 string\cf0  \cf4 `json:\'94docType\'94` \cf0 \
        ID   \cf5 string\cf0  \cf4 `json:\'94id\'94`\cf0 \
        StartBalance  \cf5 uint64\cf0  \cf4 `json:\'94startbalance\'94`\cf0 \
        Volume \cf5 uint64\cf0  \cf4 `json:\'94volume\'94`\cf0 \
        Frequency  \cf5 uint64\cf0  \cf4 `json:\'94frequency\'94`\
\cf0         Country   \cf5 string\cf0  \cf4 `json:\'94country\'94`\cf0 \
        Previous  \cf5 uint64\cf0  \cf4 `json:\'94previous\'94`\cf0 \
        Recipient \cf5 string\cf0  \cf4 `json:\'94senority\'94`\cf0 \
        EndBalance  \cf5 *bool\cf0  \cf4 `json:\'94endbalance\'94`\cf0 \
\}\
\
\cf3 /*\cf0 \
\cf3  * The Init method is used to initialize the function\cf0 \
\cf3  */in case multiple users in the organization is using the contract, this can be stopped\
\cf0 \
\cf2 func\cf0  (t *AML) Init(stub shim.ChaincodeStubInterface) sc.Response \{\
        \cf2 return\cf0  shim.Success(\cf2 nil\cf0 )\
\}\
\
\cf3  //Invoke is called every transfer on the chaincode \cf0 \
\cf3  //every transfer is either a \'93get\'94 or \'93set\'94 on the request created by the init function.\cf0 \
\cf3  //\
\cf0 \
\cf2 func\cf0  (t *AML) Invoke(stub shim.ChaincodeStubInterface) sc.Response \{\
\
        \cf3 // Retrieve the functions and args from the request\
\cf0 \
        fnc, args := APIstub.GetFunctionAndParameters()\
\
        \cf2 if\cf0  fnc == \cf4 \'93CreateTransfer\'94\cf0  \{ \cf3 //creates the transfer\cf0 \
                \cf2 return\cf0  t.CreateTransfer(stub, args)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93Amount\'94\cf0  \{ \cf3 //Amount to transfer\cf0 \
                \cf2 return\cf0  t.Amount(stub)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93Transfer\'94\cf0  \{ \cf3 //transfer to the recipient\cf0 \
                \cf2 return\cf0  t.Transfer(stub)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93queryBalance\'94\cf0  \{ \cf3 //information about the balance\cf0 \
                \cf2 return\cf0  t.queryBalance(stub, args)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93RecepientBalance\'94\cf0  \{ \cf3 // New balance for recepient \cf0 \
                \cf2 return\cf0  t.AdjustBalance(stub)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93TransferHistory\'94\cf0  \{ \cf3 //gets the history of the amounts of the transfers\cf0 \
                \cf2 return\cf0  t.TransferHistory(stub, args)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93queryAllTransfers\'94\cf0  \{ \cf3 //gets the history of all transfers\cf0 \
                \cf2 return\cf0  t.queryAllTransfers(stub, args)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93deleteamount\'94\cf0  \{ \cf3 //deletes the amount\cf0 \
                \cf2 return\cf0  t.deleteamount(stub, args)\
        \} \cf2 else\cf0  \cf2 if\cf0  fnc == \cf4 \'93LockBalance\'94\cf0  \{ \cf3 //lock balance for any further changes\cf0 \
                \cf2 return\cf0  t.LockBalance(stub, args)\
        \}\
        pmt.Println(\'93invoke function is not found:\'94 + fnc)\
        \cf2 return\cf0  shim.Error(\cf4 "Invalid Smart Contract function name."\cf0 )\
\}\
\
\cf2 func\cf0  (t *AML) CreateTransfer(stub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
        \cf4 var\cf0  err error\
\cf3 		//ID, Startbalance, seniority, country, previous, frequency, volume\cf0 \
        \cf2 if\cf0  \cf2 len\cf0 (args) != 5 \{\
        fmt.Println(\'93AML: CreateTransfers <id>, <startbalance>, <country>, <previous>, <frequency>, <volume>\'94)\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting 5\'94\cf0 )\
        \}\
\
        fmt.Println(\'93AML: Creating transfer initiated \'97-\'94)\
\
        \cf2 if len(\cf0 args[0])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'931st argument must be non-empty string\'94)\
\
        \cf2 if len(\cf0 args[1])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'932nd argument must be non-empty string\'94)\
\
        \cf2 if len(\cf0 args[2])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'933rd argument must be non-empty string\'94)\
\
        \cf2 if len(\cf0 args[3])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'934th argument must be non-empty string\'94)\
\
        \cf2 if len(\cf0 args[5])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'935th argument must be non-empty string\'94)\
\
        \cf2 if len(\cf0 args[5])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'936th argument must be non-empty string\'94)\
\
        \cf2 if len(\cf0 args[6])<= 0 \{\
                \cf2 return\cf0  shim.Error(\'937th argument must be non-empty string\'94)\
\
        id := args[0]\
\
        country := args[2]\
\
        startbalance, err := strconv.ParseUint( := args[1], 10, 64)\
        \cf2 if \cf0 err != nil \{ \
                \cf2 return\cf0  shim.Error(\'932nd argument must be a number\'94)\
\}\
        previous, err := strconv.ParseUint( := args[3], 10, 64)\
        \cf2 if \cf0 err != nil \{ \
                \cf2 return\cf0  shim.Error(\'933rd argument must be a number\'94)\
\}\
        frequency, err := strconv.ParseUint( := args[4], 10, 64)\
        \cf2 if \cf0 err != nil \{ \
                \cf2 return\cf0  shim.Error(\'934th argument must be a number\'94)\
\}\
        volume, err := strconv.ParseUint( := args[5], 10, 64)\
        \cf2 if \cf0 err != nil \{ \
                \cf2 return\cf0  shim.Error(\'935th argument must be a number\'94)\
\}\
\
        tvalbytes, err := stub.Getstate(id)\
        \cf2 if\cf0  err != nil \{\
                \cf2 return\cf0  shim.Error(\'93failed to get the current state information + err.Error())\
        \cf2 else if \cf0 tvalbytes != nil \{\
        fmt.Println(\'93This transfer is invalid\'94 + id)\
                \cf2 return\cf0  shim.Error(\'93This transfer is invalid\'94 + id)\
\}\
        objectTybe := \'93transfer\'94\
        f := \cf2 new\cf0 (bool)\
        *f = \cf4 false\
\
\cf0         transfer :=&Transfer(objective, id, startbalance, \'93\'94, country, seniority, previous, frequency, f)\
\
        tvalbytes, err = json.Marshal(transfer)\
        \cf2 if \cf0 err != nil \{ \
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        fmt.Println(\'93\'97- succes in creating the transfer\'94)\
                \cf2 return\cf0  shim.Succes(nil)\
	\
\}\
\
\
\cf2 func\cf0  (t *AML) Amount(APIstub shim.ChaincodeStubInterface), args []\cf5 string\cf0 ) sc.Response \{\
        \cf2 if \cf0 len(args) != 2 \{\cf2  \cf0 \
                \cf2 return\cf0  shim.Error(\'93Incorrect number of arguments. Expecting 2.\'94)\
\}\
        id := args[0]\
        newBalance, err := strconv.ParseUint(args[1], 10, 64)\
        fmt.Println(\'93AML: mount is initiated -\'93)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\'93\'94)\
\}\
        tvalbytes, err := stub.Getstate(id)\
        \cf2 if\cf0  err != nil \{\
                \cf2 return\cf0  shim.Error(\'93This transfer is invalid\'94 + id\'94)\
\
        \cf2 else if \cf0 tvalbytes != nil \{\
       \
                \cf2 return\cf0  shim.Error(\'93This ID does not exist\'94 + id\'94)\
\}\
\
        transfer := Transfer\{\}\
        err = json.Inmarshal(tvalbytes, &transfer)\
\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        \cf2 if \cf0 transfer.Recipient != \'93\'94 \{\
                \cf2 return\cf0  shim.Error(\'93cannot transfer to locked Balance\'93))\
\}\
\
        transfer.Amount = newAmount\
\
		transfer.recepient = NewRecepient\
\
        tvalbytes, err := json.Marshall(transfer)\
\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        err = stub.PutState(id, tvalbytes)\
\
        \cf2 if \cf0 err != nil \{\
\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        fmt.Println(\'97- succes in Amount)\
                \cf2 return\cf0  shim.Succes(nil)\
\
\
\}\
\
\
\cf2 func\cf0  (t *AML) Transfer(APIstub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
\cf3 //ID, Recepient\cf0 \
        \cf2 if\cf0  \cf2 len\cf0 (args) != \cf4 2\cf0  \{\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting 2\'94\cf0 )\
        \}\
\
        id := args[0]\
        	NewRecepient:= args[0]   \
        fmt.Println(\'93This transfer is initiated \'97-\'93)\
        tvalbytes, err := stub.GetState(id)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93failed to get the id for:\'94 + id + \'93 \'94 + err.Error()\cf0 )\
\}\
\
        transfer := Transfer\{\}\
        err = json.Inmarshal(tvalbytes, &transfer)\
\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        \cf2 if \cf0 *transfer.Locked == true \{\cf2  \
\cf0                 \cf2 return\cf0  shim.Error(\'93\cf4 can\'92t transfer when the balance is locked\'94\cf0 )\
\}\
		transfer.recepient = NewRecepient\
        tvalbytes, err := json.Marshall(transfer)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        err = stub.PutState(id, tvalbytes)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        fmt.Println(\'97- succes in transferring)\
                \cf2 return\cf0  shim.Succes(nil)\
	\
\}\
\
\
\
\cf2 func\cf0  (t *AML) queryBalance(APIstub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
        \cf2 if \cf0 len(args) != 1 \{\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting the id to query\'94\cf0 )\
\}\
        id := args[0]\
        tvalbytes, err := stub.GetState(id)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93failed to get the id for:\'94 + id \cf0 )\
\} \
      \cf2 else if \cf0 tvalbytes == nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93the id:\'94 + id + \'93does not exist\'94\cf0 )\
\
\}\
\
\
\
\cf2 func\cf0  (t *AML) RecepientBalance(APIstub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
\
        \cf2 if\cf0  \cf2 len\cf0 (args) != \cf4 2\cf0  \{\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting 2"\cf0 ))\
\}\
        id := args[0]\
        fmt.Println(\'93\'97- transferring to new recipient\'94)\
\
        tvalbytes, err := stub.GetState(id)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93failed to get the id for:\'94 + id \cf0 )\
\} \
\
      \cf2 if \cf0 tvalbytes == nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93the transfer can\'92t be found:\'94 + id \cf0 )\
\
\}\
        transfer := Transfer\{\}\
\
        err = json.Inmarshal(tvalbytes, &transfer)\
\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
\
       \cf2 if \cf0 *transfer.Locked == true \{\cf2  \
\cf0                 \cf2 return\cf0  shim.Error(\'93\cf4 can\'92t transfer when the balance is locked\'94\cf0 )\
\}\
		transfer.recepient = NewRecepient\
\
        tvalbytes, err := json.Marshall(transfer)\
\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        err = stub.PutState(id, tvalbytes)\
\
        \cf2 if \cf0 err != nil \{\
\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        fmt.Println(\'97- succes in transferring to the recipients balance)\
                \cf2 return\cf0  shim.Succes(nil)\
\}\
\
\
\cf2 func\cf0  (t *AML) TransferHistory(APIstub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
\
        \cf2 if\cf0  \cf2 len\cf0 (args) < 1 \{\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting 1\'94\cf0 )\
        \}\
\
        id := args[0]\
        fmt.Println(\'93\'97- transferring to new recipient\'94)\
        ResultsIterator, err := stub.GetHistoryForKey(id)\
        \cf2 if\cf0  err != \cf2 nil\cf0  \{\
                \cf2 return\cf0  shim.Error(err.Error())\
\}\
        defer ResultsIterator.Close()\
\
        \cf2 var \cf0 buffer bytes.Buffer\
            buffer.WriteString(\cf4 \'93[\'94\cf0 )\
            written := false\
\
       \cf2 for \cf0 ResultsIterator.HasNext() \{\
            response, err := resultsIterator.Next()\
                \cf2 if\cf0  err != \cf2 nil\cf0  \{\
                        \cf2 return\cf0  shim.Error(err.Error())\
\}\
\
\
                \cf2 if\cf0  written == \cf2 true\cf0  \{\
                        buffer.WriteString(\cf4 ","\cf0 )\
\}\
\
                buffer.WriteString(\cf4 \'93\{\cf6 \\\'94Tx\cf4 Id\cf6 \\\'94\cf4 :\'94\cf0 )\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
                buffer.WriteString(response.TxId)\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
\
                buffer.WriteString(\cf4 \'93,\\\'94value\\\'94:\'94\cf0 )\
                \cf2 if \cf0 response.IsDelete \{\
                        buffer.WriteString(\cf4 \'93null\'94\cf0 )\
                \} \cf2 else \cf0 \{\
                		   buffer.WriteString(response.Value)\
\}\
                buffer.WriteString(\cf4 \'93,\\\'94timestamp\\\'94:\'94\cf0 )\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
                buffer.WriteString(response.Timestamp.Seconds,int64(response.Timestamp.Nanos)).string.())\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
\
                buffer.WriteString(\cf4 \'93\{\cf6 \\\'94IsDelete\\\'94\cf4 :\'94\cf0 )\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
                buffer.WriteString(strconv.FormatBool(response.IsDelete))\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
\
                buffer.WriteString(\cf4 "\}"\cf0 )\
                written = \cf2 true\cf0 \
\}\
\
        buffer.WriteString(\cf4 "]"\cf0 )\
\
        fmt.Printf(\cf4 \'93\'97 Succes: result:\cf6 \\n\cf4 %s\cf6 \\n\cf4 \'94\cf0 , buffer.String())\
\
        \cf2 return\cf0  shim.Success(buffer.Bytes())\
\
\}\
\
\
\cf2 func\cf0  (t *AML) queryAllTransfers(APIstub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
\
        startKey := \cf4 ""\cf0 \
        endKey := \cf4 ""\cf0 \
\
        queryResultsIterator, err := stub.GetStateByRange(startKey, endKey)\
        \cf2 if\cf0  err != \cf2 nil\cf0  \{\
                \cf2 return\cf0  shim.Error(err.Error())\
        \}\
\
        buffer.WriteString(\cf4 "["\cf0 )\
        written := false\
        \cf2 for \cf0 queryResultsIterator.HasNext() \{\
            queryResponse, err := resultsIterator.Next()\
                \cf2 if\cf0  err != \cf2 nil\cf0  \{\
                        \cf2 return\cf0  shim.Error(err.Error())\
                \}\
\
\
                \cf2 if\cf0  written == \cf2 true\cf0  \{\
                        buffer.WriteString(\cf4 ","\cf0 )\
                \}\
\
                buffer.WriteString(\cf4 \'93\{\cf6 \\\'94\cf4 id\cf6 \\\'94\cf4 :\'94\cf0 )\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
                buffer.WriteString(queryResult.Key)\
                buffer.WriteString(\cf4 "\cf6 \\"\cf4 "\cf0 )\
\
                buffer.WriteString(\cf4 ", \cf6 \\\'94\cf4 transfer\cf6 \\\'94\cf4 :\'94\cf0 )\
\
                buffer.WriteString(\cf5 string\cf0 (queryResult.Value))\
                buffer.WriteString(\cf4 "\}"\cf0 )\
                written = \cf2 true\cf0 \
        \}\
\
        buffer.WriteString(\cf4 "]"\cf0 )\
\
        fmt.Printf(\cf4 \'93\'97 Succes: result:\cf6 \\n\cf4 %s\cf6 \\n\cf4 \'94\cf0 , buffer.String())\
\
        \cf2 return\cf0  shim.Success(buffer.Bytes())\
\
\}\
\
\
\
\cf2 func\cf0  (t *AML) deleteamount(stub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
        \cf2 if\cf0  \cf2 len\cf0 (args) != \cf4 1\cf0  \{\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting id\'94\cf0 ))\
\}\
        id := args[0]\
\
        tvalbytes, err := stub.GetState(id)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93failed to get the id for:\'94 + id \cf0 )\
\
        \}\cf2 else if \cf0 tvalbytes == nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93the id:\'94 + id + \'93does not exist\'94\cf0 )\
\
\}\
\
        err = stub.DelState(id)\
       \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93failed to remove amount\'94 \cf0 )\
\}\
                \cf2 return\cf0  shim.Succes(nil)\
\}\
\
\
\cf2 func\cf0  (t *AML) LockBalance(APIstub shim.ChaincodeStubInterface, args []\cf5 string\cf0 ) sc.Response \{\
\
        \cf2 if\cf0  \cf2 len\cf0 (args) < 1 \{\
                \cf2 return\cf0  shim.Error(\cf4 "Incorrect number of arguments. Expecting 1\'94\cf0 )\
        \}\
\
        id := args[0]\
\
        tvalbytes, err := stub.GetState(id)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93failed to get the id for:\'94 + id \cf0 )\
\} \
      \cf2 else if \cf0 tvalbytes == nil \{\
                \cf2 return\cf0  shim.Error(\cf4 \'93the id:\'94 + id + \'93does not exist\'94\cf0 )\
\}\
        transfer := Transfer()\
        err =json.Unmarshal(tvalbytes, &transfer)\
\
        if transfer.Volume == \'93\'94 \{\
        \cf2 return\cf0  shim.Error(\cf4 "Incorrect can\'92t lock balance\'94\cf0 )\
\}\
\
        f := \cf2 new\cf0 (bool)\
        *f = \cf4 true\
\
\cf0         transfer.Locked := \cf2 f\cf0 \
        tvalbytes, err = json.Marshal(transfer)\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err\cf4 .Error\cf0 )\
\}\
        err = stub.PutState(id, tvalbytes)\
\
        \cf2 if \cf0 err != nil \{\
                \cf2 return\cf0  shim.Error(err\cf4 .Error\cf0 )\
\}\
        fmt.Println(\'93\'97- succes in locking balance\'94)\
                \cf2 return\cf0  shim.Succes(nil)\cf4 \
\cf0 \
\}\
\
\
\cf3 // The main function starts the chaincode in container when initializing \cf0 \
\cf2 func\cf0  main() \{\
\
        \cf3 // Create a new Smart Contract\cf0 \
        err := shim.Start(\cf2 new\cf0 (AML))\
        \cf2 if\cf0  err != \cf2 nil\cf0  \{\
                fmt.Printf(\cf4 "Error starting AML chaincode: %s"\cf0 , err)\
        \}\
\}\
\
}